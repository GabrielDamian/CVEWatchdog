undici: 5.28.3  
"busboy": "^1.6.0"  
"node": ">=12.18"  
tether:  
undici: 5.22.1  
busboy: 1.6.0  
"undici": "5.28.3"  
"undici": "5.28.3"  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3"  
"undici": "5.28.3"  
specifier: 5.28.3 version: 5.28.3  
"undici": "^6.4.0",  
"undici": "6.3.0",  
version:  
specifier: 6.3.0 version: 6.3.0  
undici: 6.3.0  
 
undici: 6.3.0  
'@builder.io/qwik':  
'@builder.io/qwik':  
'@builder.io/qwik':  
'@builder.io/qwik':  
dependencies: '@fastify/busboy': 2.0.0  
"undici": "6.3.0",  
version:  
specifier: 6.3.0 version: 6.3.0  
undici: 6.3.0  
 
undici: 6.3.0  
'@builder.io/qwik':  
'@builder.io/qwik':  
'@builder.io/qwik':  
'@builder.io/qwik':  
dependencies: '@fastify/busboy': 2.0.0  
"version": "5.28.3", "license": "MIT",  
undici: 5.28.3  
"version": "0.41.4",  
"version": "0.41.4",  
"version": "5.28.3", "license": "MIT",  
"version": "5.28.3",  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
var require_constants = __commonJS({  
function options = void 0) {  
structuredClone: structuredClone2,  
if (actualBase64URL === expectedValue) {  
const supportedHashes =  
if (parsedToken === null || parsedToken.groups === void 0) {  
 
var { DOMException: DOMException2, structuredClone: structuredClone2 } =  
const out2Clone = { transfer: [out2] });  
var require_constants2 = __commonJS({  
var constants =  
} =  
} =  
} =  
var { DOMException: DOMException2 } =  
var require_constants3 = __commonJS({  
var { } =  
var require_constants4 = __commonJS({  
var { states, opcodes } =  
var { uid, states } =  
var { maxUnsigned16Bit } =  
var { parserStates, opcodes, states, emptyBuffer } =  
var { DOMException: DOMException2 } =  
var { states, opcodes, emptyBuffer } =  
var require_constants5 = __commonJS({  
var c =  
var constants =  
kConstruct:  
RequestRetryError  
var require_constants6 = __commonJS({  
} =  
* @param {Uint8Array} key  
this.code = key[index];  
* @param {Uint8Array} key  
* @param {number} index  
add(key, value, index) { if (index === void 0 || index >= key.length) {  
this.left = new _TstNode(key, value, index);  
if (code >= 65 && code <= 90) {  
* @param {Uint8Array} key  
this.node.add(key, value, 0);  
key);  
var { } =  
if return headers;  
const ret = [];  
var hasToWellFormed =  
fastTimers.pop();  
len -= 1;  
idx += 1;  
if (fastTimers.length > 0) { refreshTimeout();  
this.state = 0;  
clear() { this.state = -1;  
}
-});
module2.exports = { getGlobalOrigin, setGlobalOrigin };  
if { mimeType = "text/plain" + mimeType;  
if (position.position > input.length) { return "failure";  
 
if (position.position > input.length) { break;  
if { return "application/xml";  
return "allowed";  
return true;  
if (policy !== "") { = policy;  
} return false;  
return result;  
function {  
configurable: true  
return  
return input;  
if !== 61) {  
if (allowWhitespace) {  
(char) => char === "	" || char === " ", data,  
callback();  
}; function createInflate() { return new InflateStream();  
if (mimeType == null) {  
return mimeType;  
return values;  
return  
//  
module2) {  
var { types } = var { toUSVString } = require_util10();  
message: `Could not convert ${V} to an integer.`  
return (V) => {  
const method =  
const keys2 = Object.keys(O);  
message: `Expected ${V} to be an instance of ${i.name}.`  
prefix: `${V}`, argument: `${V}`,  
argument: `${V}`,  
const body = { stream: stream2, source, length }; return [body, type];  
return extractBody(object, keepalive);  
stream2[kBodyUsed] = true; yield* stream2;  
}; return methods;  
function { if (buffer.length === 0) { return "";  
const output = return output;  
function { return  
return mimeType;  
this.body.on("end", this.endHandler);  
onResponseStarted() { return  
return skipAppend ? val : `${key}: ${val}\r `;  
request.headers += val[i]);  
module2.exports = Request;  
module2.exports = Dispatcher;  
module2.exports = DispatcherBase; } });  
 
new  
module2.exports = buildConnector; } });  
exports2.enumToMap = enumToMap;  
var util2 = require_util9(); var { kBodyUsed } = require_symbols6();  
onError(error2) {  
} onData(chunk) { if (this.location) {  
return  
 
return false;  
} else { assert(headers == null, "headers must be an object or an array");  
return ret;
module2.exports = RedirectHandler;  
module2.exports = } });  
var Request = require_request3(); var DispatcherBase =  
 
 
var buildConnector = require_connect2();  
kServerName,  
kBusy,
kConnect,
kResuming,
kConnected, kConnecting, kNeedDrain,  
kConnector, kMaxRedirections,  
kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress,  
set pipelining(value) { this[kPipelining] = value; resume(this, true);  
get [kPending]() { return this[kQueue].length - this[kPendingIdx];  
get [kRunning]() { return this[kPendingIdx] - this[kRunningIdx];  
get [kSize]() { return this[kQueue].length - this[kRunningIdx];  
return this[kNeedDrain] < 2;  
resume(this); }); } };  
err);  
err);  
util2.destroy(this, new SocketError("other side closed"));  
resume(client);  
 
throw new  
} catch (err) { err); }  
onStatus(buf) { this.statusText = buf.toString();  
 
if (request.method === "HEAD") { return 1;  
if (statusCode < 200) { return 1;  
if (socket[kBlocking]) { socket[kBlocking] = false; resume(client);  
if (upgrade) { return;  
resume(client);  
=== 0);  
this[kParser] = null;  
} else { onError(client, err);  
client[kUrl], [client], err);  
resume(client);  
if (client[kPending] === 0) { return;  
if (client[kRunning] >= || 1)) { return;  
if { return;  
if (!socket && { connect(client); return;  
if (client[kRunning] > 0 && { return;  
if (contentLength === 0 || !expectsPayload) { contentLength = null;  
util2.destroy(body, err); err);  
 
if && this.pause) { this.pause(); }  
}; const onFinished = function(err) { if (finished) {  
 
socket.on("drain", onFinished);  
const len = if (!len) { return true;  
${contentLength}\r \r `, "latin1");  
if (socket.destroyed) {  
};
//  
module2) {  
//  
module2) {  
//  
module2) {  
process.nextTick(() => {  
//  
module2) {  
//  
module2) {  
//  
module2) {  
var =  
var kAbort = Symbol("abort");  
module2.exports = class BodyReadable extends Readable {  
let limit = ? opts.limit : 262144;  
var { toUSVString } = require_util9();  
let limit = 0;  
limit += chunk.length; if (limit > 128 * 1024) {  
module2.exports = { };  
var Readable =  
const body = new Readable({ resume, abort, contentType, highWaterMark });  
throw new dispatch not matched for method '${key.method}'`);  
throw new dispatch not matched for body '${key.body}'`);  
getHeaderByName  
if (typeof responseOptions !== "object") {  
module2.exports = RetryHandler;  
//  
module2) {  
makeIterator,  
for (const [name, { value }] of this[kHeadersMap]) {  
const names = b) => a[0] < b[0] ? -1 : 1);  
const [name, value] = names[i];  
assert(value !== null);  
=  
//  
module2) {  
} =  
var { URLSerializer } = require_dataURL2();  
//  
//  
module2) {  
} =  
var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols7();  
var { URLSerializer } = require_dataURL2();  
// navigation (a.k.a. back-foward navigation).  
module2.exports = { Request, makeRequest, fromInnerRequest };  
//  
module2) {  
var { Request, makeRequest } = require_request4();  
var { kState } = require_symbols7();  
} =  
var { dataURLProcessor, serializeAMimeType, } = require_dataURL2();  
 
return Promise.resolve();  
return Promise.resolve();  
return Promise.resolve();  
dispatcher: init?.dispatcher ??  
dispatcher
queuingStrategy: new highWaterMark: 16384 }),  
httpRequest =  
highWaterMark: 16384,  
response.body = { stream: stream2 };  
//  
module2) {  
//  
//  
module2) {  
//  
module2) {  
var { serializeAMimeType, parseMIMEType } = require_dataURL2();  
//  
//  
module2) {  
//  
module2) {  
var { URLSerializer } = require_dataURL2();  
function fieldValues(header) {  
values.push(value);  
fieldValues
//  
module2) {  
var { urlEquals, fieldValues: getFieldValues } = require_util13();  
var { getGlobalDispatcher } = require_global4();  
dispatcher:  
//  
//  
module2) {  
for (const char of value) { const code = char.charCodeAt(0);  
//  
module2) {  
var { } =  
var { } = require_dataURL2();  
//  
module2) {  
 
//  
module2) {  
//  
module2) {  
var { states, opcodes } =  
//  
var { uid, states } =  
var { getGlobalDispatcher } = require_global4();  
dispatcher: options.dispatcher ??  
const wasClean = ws[kSentClose] && ws[kReceivedClose];  
} else if (!ws[kSentClose]) {  
//  
module2) {  
var { maxUnsigned16Bit } =  
//  
var { parserStates, opcodes, states, emptyBuffer } =  
this.ws[kSentClose] = true;  
data) {  
//  
var { URLSerializer } = require_dataURL2();  
var { states, opcodes, emptyBuffer } =  
} else if (!isClosing(this)) {  
this[kSentClose] = true;  
if (this[kReadyState] === {  
//  
module2) {  
//  
//  
var { parseMIMEType } = require_dataURL2();  
var { getGlobalDispatcher } = require_global4();  
var errors = require_errors2();  
var ProxyAgent = var RetryHandler =  
if (typeof err === "object") {  
var { parseMIMEType, serializeAMimeType } = require_dataURL2();  
 
 
var require_constants = __commonJS({  
function options = void 0) {  
structuredClone: structuredClone2,  
if (actualBase64URL === expectedValue) {  
const supportedHashes =  
if (parsedToken === null || parsedToken.groups === void 0) {  
 
var { DOMException: DOMException2, structuredClone: structuredClone2 } =  
const out2Clone = { transfer: [out2] });  
var require_constants2 = __commonJS({  
var constants =  
} =  
} =  
} =  
var { DOMException: DOMException2 } =  
var require_constants3 = __commonJS({  
var { } =  
var require_constants4 = __commonJS({  
var { states, opcodes } =  
var { uid, states } =  
var { maxUnsigned16Bit } =  
var { parserStates, opcodes, states, emptyBuffer } =  
var { DOMException: DOMException2 } =  
var { states, opcodes, emptyBuffer } =  
kConstruct:  
RequestRetryError  
var require_constants5 = __commonJS({  
} =  
* @param {Uint8Array} key  
this.code = key[index];  
* @param {Uint8Array} key  
* @param {number} index  
add(key, value, index) { if (index === void 0 || index >= key.length) {  
this.left = new _TstNode(key, value, index);  
if (code >= 65 && code <= 90) {  
* @param {Uint8Array} key  
this.node.add(key, value, 0);  
key);  
var { } =  
if return headers;  
const ret = [];  
var hasToWellFormed =  
fastTimers.pop();  
len -= 1;  
idx += 1;  
if (fastTimers.length > 0) { refreshTimeout();  
this.state = 0;  
clear() { this.state = -1;  
}
-});
module2.exports = { getGlobalOrigin, setGlobalOrigin };  
if { mimeType = "text/plain" + mimeType;  
if (position.position > input.length) { return "failure";  
 
if (position.position > input.length) { break;  
if { return "application/xml";  
return "allowed";  
return true;  
if (policy !== "") { = policy;  
} return false;  
return result;  
function {  
configurable: true  
return  
return input;  
if !== 61) {  
if (allowWhitespace) {  
(char) => char === "	" || char === " ", data,  
callback();  
}; function createInflate() { return new InflateStream();  
if (mimeType == null) {  
return mimeType;  
return values;  
return  
//  
module2) {  
var { types } = var { toUSVString } = require_util10();  
message: `Could not convert ${V} to an integer.`  
return (V) => {  
const method =  
const keys2 = Object.keys(O);  
message: `Expected ${V} to be an instance of ${i.name}.`  
prefix: `${V}`, argument: `${V}`,  
argument: `${V}`,  
const body = { stream, source, length }; return [body, type];  
return extractBody(object, keepalive);  
stream[kBodyUsed] = true; yield* stream;  
}; return methods;  
function { if (buffer.length === 0) { return "";  
return mimeType;  
this.body.on("end", this.endHandler);  
onResponseStarted() { return  
return skipAppend ? val : `${key}: ${val}\r `;  
request.headers += val[i]);  
module2.exports = Request;  
module2.exports = Dispatcher;  
module2.exports = DispatcherBase; } });  
 
new  
module2.exports = buildConnector; } });  
exports2.enumToMap = enumToMap;  
var util = require_util9(); var { kBodyUsed } = require_symbols6();  
onError(error) {  
} onData(chunk) { if (this.location) {  
return  
 
return false;  
} else { assert(headers == null, "headers must be an object or an array");  
return ret;
module2.exports = RedirectHandler;  
module2.exports = } });  
var Request = require_request3(); var DispatcherBase =  
 
 
var buildConnector = require_connect2();  
kServerName,  
kBusy,
kConnect,
kResuming,
kConnected, kConnecting, kNeedDrain,  
kConnector, kMaxRedirections,  
kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress,  
set pipelining(value) { this[kPipelining] = value; resume(this, true);  
get [kPending]() { return this[kQueue].length - this[kPendingIdx];  
get [kRunning]() { return this[kPendingIdx] - this[kRunningIdx];  
get [kSize]() { return this[kQueue].length - this[kRunningIdx];  
return this[kNeedDrain] < 2;  
resume(this); }); } };  
err);  
err);  
util.destroy(this, new SocketError("other side closed"));  
resume(client);  
 
throw new  
} catch (err) { err); }  
onStatus(buf) { this.statusText = buf.toString();  
 
if (request.method === "HEAD") { return 1;  
if (statusCode < 200) { return 1;  
if (socket[kBlocking]) { socket[kBlocking] = false; resume(client);  
if (upgrade) { return;  
resume(client);  
=== 0);  
this[kParser] = null;  
} else { onError(client, err);  
client[kUrl], [client], err);  
resume(client);  
if (client[kPending] === 0) { return;  
if (client[kRunning] >= || 1)) { return;  
if { return;  
if (!socket && { connect(client); return;  
if (client[kRunning] > 0 && { return;  
if (contentLength === 0 || !expectsPayload) { contentLength = null;  
util.destroy(body, err); err);  
 
if && this.pause) { this.pause(); }  
}; const onFinished = function(err) { if (finished) {  
util.destroy(body);  
socket.on("drain", onFinished);  
const len = if (!len) { return true;  
${contentLength}\r \r `, "latin1");  
if (socket.destroyed) {  
};
//  
module2) {  
//  
module2) {  
//  
module2) {  
process.nextTick(() => {  
//  
module2) {  
//  
module2) {  
//  
module2) {  
var =  
var kAbort = Symbol("abort");  
module2.exports = class BodyReadable extends Readable {  
let limit = ? opts.limit : 262144;  
var { toUSVString } = require_util9();  
let limit = 0;  
limit += chunk.length; if (limit > 128 * 1024) {  
module2.exports = { };  
var Readable =  
const body = new Readable({ resume, abort, contentType, highWaterMark });  
throw new dispatch not matched for method '${key.method}'`);  
throw new dispatch not matched for body '${key.body}'`);  
getHeaderByName  
if (typeof responseOptions !== "object") {  
module2.exports = RetryHandler;  
//  
module2) {  
makeIterator,  
for (const [name, { value }] of this[kHeadersMap]) {  
const names = b) => a[0] < b[0] ? -1 : 1);  
const [name, value] = names[i];  
assert(value !== null);  
=  
//  
module2) {  
} =  
var { URLSerializer } = require_dataURL2();  
//  
//  
module2) {  
} =  
var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols7();  
var { URLSerializer } = require_dataURL2();  
// navigation (a.k.a. back-foward navigation).  
module2.exports = { Request, makeRequest, fromInnerRequest };  
//  
module2) {  
var { Request, makeRequest } = require_request4();  
var { kState } = require_symbols7();  
} =  
var { dataURLProcessor, serializeAMimeType, } = require_dataURL2();  
 
return Promise.resolve();  
return Promise.resolve();  
return Promise.resolve();  
dispatcher: init?.dispatcher ??  
dispatcher
queuingStrategy: new highWaterMark: 16384 }),  
httpRequest =  
highWaterMark: 16384,  
response.body = { stream };  
//  
module2) {  
//  
//  
module2) {  
//  
module2) {  
var { serializeAMimeType, parseMIMEType } = require_dataURL2();  
//  
//  
module2) {  
//  
module2) {  
var { URLSerializer } = require_dataURL2();  
function fieldValues(header) {  
values.push(value);  
fieldValues
//  
module2) {  
var { urlEquals, fieldValues: getFieldValues } = require_util13();  
var { getGlobalDispatcher } = require_global4();  
dispatcher:  
//  
//  
module2) {  
for (const char of value) { const code = char.charCodeAt(0);  
//  
module2) {  
var { } =  
var { } = require_dataURL2();  
//  
module2) {  
 
//  
module2) {  
//  
module2) {  
var { states, opcodes } =  
//  
var { uid, states } =  
var { getGlobalDispatcher } = require_global4();  
dispatcher: options.dispatcher ??  
const wasClean = ws[kSentClose] && ws[kReceivedClose];  
} else if (!ws[kSentClose]) {  
//  
module2) {  
var { maxUnsigned16Bit } =  
//  
var { parserStates, opcodes, states, emptyBuffer } =  
this.ws[kSentClose] = true;  
data) {  
//  
var { URLSerializer } = require_dataURL2();  
var { states, opcodes, emptyBuffer } =  
} else if (!isClosing(this)) {  
this[kSentClose] = true;  
if (this[kReadyState] === {  
//  
module2) {  
//  
//  
var { parseMIMEType } = require_dataURL2();  
var { getGlobalDispatcher } = require_global4();  
var errors = require_errors3();  
var ProxyAgent = var RetryHandler =  
if (typeof err === "object") {  
var { parseMIMEType, serializeAMimeType } = require_dataURL2();  
 
 
var require_constants = __commonJS({  
function options = void 0) {  
structuredClone: structuredClone2,  
if (actualBase64URL === expectedValue) {  
const supportedHashes =  
if (parsedToken === null || parsedToken.groups === void 0) {  
 
var { DOMException: DOMException2, structuredClone: structuredClone2 } =  
const out2Clone = { transfer: [out2] });  
var require_constants2 = __commonJS({  
var constants =  
} =  
} =  
} =  
var { DOMException: DOMException2 } =  
var require_constants3 = __commonJS({  
var { } =  
var require_constants4 = __commonJS({  
var { states, opcodes } =  
var { uid, states } =  
var { maxUnsigned16Bit } =  
var { parserStates, opcodes, states, emptyBuffer } =  
var { DOMException: DOMException2 } =  
var { states, opcodes, emptyBuffer } =  
kConstruct:  
RequestRetryError  
var require_constants5 = __commonJS({  
} =  
* @param {Uint8Array} key  
this.code = key[index];  
* @param {Uint8Array} key  
* @param {number} index  
add(key, value, index) { if (index === void 0 || index >= key.length) {  
this.left = new _TstNode(key, value, index);  
if (code >= 65 && code <= 90) {  
* @param {Uint8Array} key  
this.node.add(key, value, 0);  
key);  
var { } =  
if return headers;  
const ret = [];  
var hasToWellFormed =  
fastTimers.pop();  
len -= 1;  
idx += 1;  
if (fastTimers.length > 0) { refreshTimeout();  
this.state = 0;  
clear() { this.state = -1;  
}
-});
module2.exports = { getGlobalOrigin, setGlobalOrigin };  
if { mimeType = "text/plain" + mimeType;  
if (position.position > input.length) { return "failure";  
 
if (position.position > input.length) { break;  
if { return "application/xml";  
return "allowed";  
return true;  
if (policy !== "") { = policy;  
} return false;  
return result;  
function {  
configurable: true  
return  
return input;  
if !== 61) {  
if (allowWhitespace) {  
(char) => char === "	" || char === " ", data,  
callback();  
}; function createInflate() { return new InflateStream();  
if (mimeType == null) {  
return mimeType;  
return values;  
return  
//  
module2) {  
var { types } = var { toUSVString } = require_util10();  
message: `Could not convert ${V} to an integer.`  
return (V) => {  
const method =  
const keys2 = Object.keys(O);  
message: `Expected ${V} to be an instance of ${i.name}.`  
prefix: `${V}`, argument: `${V}`,  
argument: `${V}`,  
const body = { stream, source, length }; return [body, type];  
return extractBody(object, keepalive);  
stream[kBodyUsed] = true; yield* stream;  
}; return methods;  
function { if (buffer.length === 0) { return "";  
return mimeType;  
this.body.on("end", this.endHandler);  
onResponseStarted() { return  
return skipAppend ? val : `${key}: ${val}\r `;  
request.headers += val[i]);  
module2.exports = Request;  
module2.exports = Dispatcher;  
module2.exports = DispatcherBase; } });  
 
new  
module2.exports = buildConnector; } });  
exports2.enumToMap = enumToMap;  
var util = require_util9(); var { kBodyUsed } = require_symbols6();  
onError(error) {  
} onData(chunk) { if (this.location) {  
return  
 
return false;  
} else { assert(headers == null, "headers must be an object or an array");  
return ret;
module2.exports = RedirectHandler;  
module2.exports = } });  
var Request = require_request3(); var DispatcherBase =  
 
 
var buildConnector = require_connect2();  
kServerName,  
kBusy,
kConnect,
kResuming,
kConnected, kConnecting, kNeedDrain,  
kConnector, kMaxRedirections,  
kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress,  
set pipelining(value) { this[kPipelining] = value; resume(this, true);  
get [kPending]() { return this[kQueue].length - this[kPendingIdx];  
get [kRunning]() { return this[kPendingIdx] - this[kRunningIdx];  
get [kSize]() { return this[kQueue].length - this[kRunningIdx];  
return this[kNeedDrain] < 2;  
resume(this); }); } };  
err);  
err);  
util.destroy(this, new SocketError("other side closed"));  
resume(client);  
 
throw new  
} catch (err) { err); }  
onStatus(buf) { this.statusText = buf.toString();  
 
if (request.method === "HEAD") { return 1;  
if (statusCode < 200) { return 1;  
if (socket[kBlocking]) { socket[kBlocking] = false; resume(client);  
if (upgrade) { return;  
resume(client);  
=== 0);  
this[kParser] = null;  
} else { onError(client, err);  
client[kUrl], [client], err);  
resume(client);  
if (client[kPending] === 0) { return;  
if (client[kRunning] >= || 1)) { return;  
if { return;  
if (!socket && { connect(client); return;  
if (client[kRunning] > 0 && { return;  
if (contentLength === 0 || !expectsPayload) { contentLength = null;  
util.destroy(body, err); err);  
 
if && this.pause) { this.pause(); }  
}; const onFinished = function(err) { if (finished) {  
util.destroy(body);  
socket.on("drain", onFinished);  
const len = if (!len) { return true;  
${contentLength}\r \r `, "latin1");  
if (socket.destroyed) {  
};
//  
module2) {  
//  
module2) {  
//  
module2) {  
process.nextTick(() => {  
//  
module2) {  
//  
module2) {  
//  
module2) {  
var =  
var kAbort = Symbol("abort");  
module2.exports = class BodyReadable extends Readable {  
let limit = ? opts.limit : 262144;  
var { toUSVString } = require_util9();  
let limit = 0;  
limit += chunk.length; if (limit > 128 * 1024) {  
module2.exports = { };  
var Readable =  
const body = new Readable({ resume, abort, contentType, highWaterMark });  
throw new dispatch not matched for method '${key.method}'`);  
throw new dispatch not matched for body '${key.body}'`);  
getHeaderByName  
if (typeof responseOptions !== "object") {  
module2.exports = RetryHandler;  
//  
module2) {  
makeIterator,  
for (const [name, { value }] of this[kHeadersMap]) {  
const names = b) => a[0] < b[0] ? -1 : 1);  
const [name, value] = names[i];  
assert(value !== null);  
=  
//  
module2) {  
} =  
var { URLSerializer } = require_dataURL2();  
//  
//  
module2) {  
} =  
var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols7();  
var { URLSerializer } = require_dataURL2();  
// navigation (a.k.a. back-foward navigation).  
module2.exports = { Request, makeRequest, fromInnerRequest };  
//  
module2) {  
var { Request, makeRequest } = require_request4();  
var { kState } = require_symbols7();  
} =  
var { dataURLProcessor, serializeAMimeType, } = require_dataURL2();  
 
return Promise.resolve();  
return Promise.resolve();  
return Promise.resolve();  
dispatcher: init?.dispatcher ??  
dispatcher
queuingStrategy: new highWaterMark: 16384 }),  
httpRequest =  
highWaterMark: 16384,  
response.body = { stream };  
//  
module2) {  
//  
//  
module2) {  
//  
module2) {  
var { serializeAMimeType, parseMIMEType } = require_dataURL2();  
//  
//  
module2) {  
//  
module2) {  
var { URLSerializer } = require_dataURL2();  
function fieldValues(header) {  
values.push(value);  
fieldValues
//  
module2) {  
var { urlEquals, fieldValues: getFieldValues } = require_util13();  
var { getGlobalDispatcher } = require_global4();  
dispatcher:  
//  
//  
module2) {  
for (const char of value) { const code = char.charCodeAt(0);  
//  
module2) {  
var { } =  
var { } = require_dataURL2();  
//  
module2) {  
 
//  
module2) {  
//  
module2) {  
var { states, opcodes } =  
//  
var { uid, states } =  
var { getGlobalDispatcher } = require_global4();  
dispatcher: options.dispatcher ??  
const wasClean = ws[kSentClose] && ws[kReceivedClose];  
} else if (!ws[kSentClose]) {  
//  
module2) {  
var { maxUnsigned16Bit } =  
//  
var { parserStates, opcodes, states, emptyBuffer } =  
this.ws[kSentClose] = true;  
data) {  
//  
var { URLSerializer } = require_dataURL2();  
var { states, opcodes, emptyBuffer } =  
} else if (!isClosing(this)) {  
this[kSentClose] = true;  
if (this[kReadyState] === {  
//  
module2) {  
//  
//  
var { parseMIMEType } = require_dataURL2();  
var { getGlobalDispatcher } = require_global4();  
var errors = require_errors3();  
var ProxyAgent = var RetryHandler =  
if (typeof err === "object") {  
var { parseMIMEType, serializeAMimeType } = require_dataURL2();  
 
 
undici: 5.28.3  
undici: 5.28.3  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
"version": "5.28.3", "license": "MIT",  
"hardhat": "^2.21.0",  
"license": "MIT",  
"license": "MIT",  
"license": "MIT",  
"^0.2.0",  
"license": "MIT",  
undici: 5.28.3  
undici: 5.28.3  
undici: 5.28.3  
"prettier": "latest",  
"turbo": "latest",  
undici: 5.28.3  
undici: 5.28.3  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
 
 
 
"@types/node@*", "@types/node@>= 8",  
 
"acorn@^6.0.0 || ^7.0.0 || ^8.0.0", acorn@^8.9.0:  
babel-jest@^29.0.0, babel-jest@^29.7.0:  
"browserslist@>= 4.21.0":  
estraverse@^5.2.0:  
find-up@^4.1.0:
jest-resolve@*,  
jest@^29.0.0, jest@^29.7.0:  
prettier@>=3.0.0, prettier@3.0.3:  
rimraf@^3.0.2, rimraf@3.0.2:  
semver@^5.5.0:
semver@^6.3.1:
tunnel@^0.0.6, tunnel@0.0.6:  
 
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3",  
"undici": "5.28.3"  
"version": "1.0.0",  
"version": "1.0.0",  
undici: 5.28.3  
undici: 5.28.3  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
"version": "5.28.3", "license": "MIT",  
"version": "5.28.3",  
"undici": "^5.28.3",  
"undici": "^5.28.3",  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
undici: 5.28.3  
undici: 5.28.3  
"@types/node": ">=13.7.0", "long": "^5.0.0"  
"@types/node": ">=13.7.0", "long": "^5.0.0"  
"@types/node": ">=13.7.0", "long": "^5.0.0"  
"is-glob": "^4.0.1"  
"brace-expansion": "^1.1.7"  
"brace-expansion": "^1.1.7"  
"node-gyp-build": "^4.2.0"  
"is-glob": "^4.0.1"  
"is-extglob": "^2.1.1"  
"brace-expansion": "^1.1.7"  
"brace-expansion": "^1.1.7"  
"node-gyp-build": "^4.2.0"  
"ip": "^1.1.5"  
"buffer": "^5.5.0",  
"long": "^5.0.0"  
"debug": "~4.1.0",  
"base64-js": "^1.3.1", "ieee754": "^1.1.13"  
"optional": true,  
"optional": true,  
"optional": true,  
"optional": true,  
"dev": true, "optional": true  
"dev": true, "optional": true  
"optional": true,  
"is-glob": "^4.0.1"  
"^6.0.0",  
"bn.js": "^4.11.9", "brorand": "^1.1.0",  
undici: 5.28.3  
undici: 5.28.3  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
undici: 5.28.3  
"@nuxt/devtools": "latest",  
"prettier": "latest"  
// 3. If parsedMetadata is the empty set, return true.  
// 4. Let metadata be the result of getting the strongest  
// 5. For each item in metadata:  
let expectedValue = item.hash  
if { expectedValue = -2) }  
if { actualValue = -2)  
if (actualValue === expectedValue) { return true }  
let actualBase64URL =  
if (actualBase64URL === expectedValue) {  
// 6. Return false.  
const supportedHashes = crypto.getHashes()  
if (parsedToken === null || parsedToken.groups === undefined) {  
const algorithm =  
if {  
 
undici: 5.28.3  
undici: 5.28.3  

"semver": ">=7.5.2"  
"semver": ">=7.5.2"  
"semver": ">=7.5.2"  
"dev": true,  
"0.6.4", "0.6.4",  
"@firebase/util": "1.9.3",  
"0.10.0",  
"0.6.4", "@firebase/util": "1.9.3",  
"0.6.4",  
"@firebase/util": "1.9.3",  
"0.8.0",  
"0.6.4",  
"@firebase/util": "1.9.3",  
"whatwg-url": "^5.0.0"  
"whatwg-url": "^5.0.0"  
"0.6.4",  
"@firebase/util": "1.9.3",  
"@firebase/util": "1.9.3",  
"@firebase/util": "1.9.3"  
"whatwg-url": "^5.0.0"  
"whatwg-url": "^5.0.0"  
"0.6.4", "0.6.4",  
"@firebase/util": "1.9.3",  
"0.6.4", "0.6.4",  
"@firebase/util": "1.9.3", "idb": "7.0.1",  
}, "peerDependencies": { "0.x"  
"0.6.4", "0.6.4",  
"@firebase/util": "1.9.3",  
"0.6.4",  
"0.6.4",  
"@firebase/util": "1.9.3",  
"0.6.4", "0.6.4",  
"@firebase/util": "1.9.3",  
"0.6.4",  
"0.4.4",  
"@firebase/util": "1.9.3",  
"whatwg-url": "^5.0.0"  
undici: 5.28.2  
"source-map-js": "^1.0.2"  
"esbuild": "^0.19.3", "postcss": "^8.4.35", "rollup": "^4.2.0"  
"node": ">=20.12.0"  
"undici": "^6.10.2",  
"undici": "^6.10.2",  
"undici": "6.10.2",  
specifier: 6.10.2 version: 6.10.2  
difflib:  
version: 6.10.2  
"undici": "6.10.2"  
undici: 5.26.3  
undici: 5.26.3  
"postcss": "^8.4.36",  
"esbuild": "^0.19.3", "postcss": "^8.4.35", "rollup": "^4.2.0"  
"postcss": "^8.4.33",  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33",  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33"  
"postcss": "^8.4.33",  
"postcss": "^8.4.33",  
"postcss": "^8.4.33",  
"postcss": "^8.4.33",  
content-type "~1.0.4"  
raw-body "2.5.1"  
 
body-parser "1.20.1"  
cookie "0.5.0"  
source-map-js "^1.0.2"  
raw-body@^2.3.2:
"~3.29.0", "undici": ">=5.28.4"  
"undici": ">=5.28.4"  
"dependencies": { "@fastify/busboy": "^2.0.0" },  
"node": ">=14.0"  
"undici": ">=5.28.4"  
"undici": ">=5.28.4"  
"undici": "^5.28.4"  
specifier: ^5.28.4 version: 5.28.4  
"undici": "^5.27.2",  
"undici": "^5.27.2"  
"undici": "^5.27.2",  
undici: ^5.27.2  
undici: ^5.27.2  
undici: ^5.27.2  
"undici": "^6.9.0",  
"undici": "^6.9.0",  
"undici": "^6.8.0"  
"undici": "^6.8.0"  
"undici": "^5.28.2"  
"dependencies": { "@fastify/busboy": "^2.0.0" },  
"node": ">=14.0"  
"undici": "^5.28.2"  
"undici": "6.10.1",  
specifier: 6.10.1 version: 6.10.1  
"undici": "5.23.0",  
specifier: 5.23.0 version: 5.23.0  
"undici-types": "^5.28.2"  
"undici-types": "^5.28.2"  
specifier: ^5.28.2 version: 5.28.2  
specifier: ^5.28.2 version: 5.28.2  
"version": "15.0.0",  
"version": "15.0.0",  
"undici": "^5.19.1",  
"dependencies": { "busboy": "^1.6.0" },  
"node": ">=14.0"  
"undici": "^5.19.1",  
"undici": "^6.9.0",  
"undici": "^6.9.0",  
"@types/node": "^20.12.5",  
"undici": "^6.6.2"  
"undici": "^6.6.2"  
"undici": "5.28.2"  
"node": ">=14.0"  
"undici": "5.28.2"  
"undici": "^6.6.2",  
"undici": "^6.6.2",  
"undici": "^6.10.2",  
"undici": "^6.10.2",  
"undici": "^6.7.1"  
"undici": "^6.7.1"  
"undici": "^3.3.5",  
"undici": "^5.19.1"  
"undici": "6.10.1",  
specifier: 6.10.1 version: 6.10.1  
"dependencies": { "@fastify/busboy": "^2.0.0" },  
"^2.0.0",  
"devalue": "^4.2.0",  
"magic-string": "^0.27.0", "mime": "^3.0.0",  
"^2.5.1",  
"undici": "5.14.0"  
"^1.4.13"  
"busboy": "^1.6.0"  
"@sveltejs/kit": "^1.5.0",  
"vite": "^4.5.2"  
"version": "1.20.0",  
"license": "MIT",  
"^2.4.1",  
"mime": "^3.0.0",  
"undici": "~5.22.0"  
"svelte": "^3.54.0 || ^4.0.0-next.0",  
"version": "2.4.1",  
"license": "MIT",  
"^1.0.2",  
"magic-string": "^0.30.0", "svelte-hmr": "^0.15.1",  
"svelte": "^3.54.0 || ^4.0.0-next.0",  
"version": "1.0.2",  
"license": "MIT",  
"svelte": "^3.54.0 || ^4.0.0-next.0",  
"license": "MIT",  
"license": "MIT",  
"version": "0.30.0",  
"license": "MIT",  
"^1.4.13"  
"version": "0.15.2",  
"license": "ISC",  
"svelte": "^3.19.0 || ^4.0.0-next.0"  
"version": "5.22.1",  
"license": "MIT",  
"busboy": "^1.6.0"  
"version": "0.2.4",  
"license": "MIT",  
"vite": "^3.0.0 || ^4.0.0"  
"@sveltejs/kit": "^1.5.0",  
"vite": "^4.5.2"  
"vite": "^5.0.12",  
"dependencies": { "@fastify/busboy": "^2.0.0" },  
"vite": "^5.0.12",  
"^4.9.3",  
"node": "*"  
"^5.0.0-beta.146",  
"ethers": "^4.0.40",  
"mocha": "^7.1.1",  
"request": "^2.88.0", "^1.0.5",  
"engines": { "node": ">=6"  
"engines": { "node": ">=6"  
"peer": true,  
"sprintf-js": "~1.0.2"  
{  
"dev": true, "peer": true  
"peer": true, "engines": { "node": ">=6"  
"peer": true,  
"peer": true,  
"string-width": "^3.1.0", "strip-ansi": "^5.2.0", "wrap-ansi": "^5.1.0"  
"ms": "^2.1.1"  
"node": ">=0.10.0"  
"node": ">=0.3.1"  
"node": ">=4"  
"peer": true,  
"locate-path": "^3.0.0"  
"node": ">=6"  
"is-buffer": "~2.0.3" }, "bin": { "flat": "cli.js"  
"node": "^8.16.0 || ^10.6.0 || >=11.0.0"  
"node": "*"  
"peer": true,  
"js-yaml": "bin/js-yaml.js"  
"engines": { "node": ">=8"  
"brace-expansion": "^1.1.7"  
"node": "*"  
"peer": true,  
"peer": true, "dependencies": { "p-try": "^2.0.0" },  
"peer": true, "dependencies": { "p-limit": "^2.0.0" },  
"node": ">=6"  
"node": ">=6"  
{  
"dependencies": { "picomatch": "^2.0.4" },  
"node": ">= 8"  
"engines": { "node": ">=6"  
"peer": true,  
"ansi-regex": "^4.1.0"  
"node": ">=6"  
"peer": true,  
"node": ">=0.10.0"  
"has-flag": "^3.0.0"  
"flat": "^4.1.0", "lodash": "^4.17.15", "yargs": "^13.3.0"  
"peer": true,  
"mime-db": "1.52.0"  
"engines": { "node": ">= 0.6"  
"brace-expansion": "^1.1.7"  
"engines": { "node": "*"  
"peer": true, "funding": { "url":  
"peer": true,  
"minimist": "^1.2.6"  
"bin": { "mkdirp": "bin/cmd.js"  
"dependencies": { "obliterator": "^2.0.0" }  
"engines": { "node": ">=6"  
"dependencies": { "balanced-match": "^1.0.0" }  
"locate-path": "^6.0.0", "path-exists": "^4.0.0"  
"node": ">=8"  
{  
"brace-expansion": "^2.0.1"  
"node": ">=10"  
"yocto-queue": "^0.1.0"  
"dependencies": { "p-limit": "^3.0.2" },  
{  
"node": ">=10"  
"bin": { "nanoid": "bin/nanoid.cjs"  
"node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"  
"peer": true  
"peer": true, "dependencies": { "lodash": "^4.17.21"  
"peer": true,  
"^2.0.3", "semver": "^5.7.0"  
"peer": true, "bin": { "semver": "bin/semver"  
"node": ">=12.19"  
"peer": true, "dependencies": { "abbrev": "1"  
"bin": { "nopt": "bin/nopt.js"  
"engines": { "node": ">=0.10.0"  
"peer": true,  
"bn.js": "4.11.6", "strip-hex-prefix": "1.0.0"  
"engines": { "node": ">=6.5.0", "npm": ">=3"  
"peer": true  
"peer": true,  
"node": ">= 0.4"  
"peer": true,  
"node": ">= 0.8"  
"url":  
"wrappy": "1"  
"deep-is": "~0.1.3", "fast-levenshtein": "~2.0.6", "levn": "~0.3.0",  
"type-check": "~0.3.2", "word-wrap": "~1.2.3"  
"engines": { "node": ">=0.10.0" }  
"p-try": "^1.0.0"  
"node": ">=4"  
"p-limit": "^1.1.0"  
"node": ">=4"  
"aggregate-error": "^3.0.0"  
"url":  
"node": ">=4"  
"node": ">=0.10.0"  
"peer": true,  
"engines": { "node": "*"  
"node": ">=8.6"  
"funding": { "url":  
"peer": true,  
"node": ">=6"  
"node": ">= 0.8.0"  
"funding": { "url":  
"peer": true  
"asap": "~2.0.6"  
"node": ">=6"  
"engines": { "node": ">=0.6"  
"safe-buffer": "^5.1.0"  
"node": ">= 0.8"  
"node": ">= 6"  
"picomatch": "^2.2.1" }, "engines": { "node": ">=8.10.0"  
"peer": true, "dependencies": { "resolve": "^1.1.6" },  
"node": ">= 0.10"  
"peer": true,  
"minimatch": "^3.0.5"  
"node": ">=6.0.0"  
"peer": true,  
"node": ">=6"  
"peer": true,  
"node": ">= 0.4"  
"url":  
"peer": true,  
"req-from": "^2.0.0"  
"node": ">=4"  
"peer": true,  
"resolve-from": "^3.0.0"  
"node": ">=4"  
"peer": true,  
"node": ">= 6"  
"peer": true, "dependencies": { "lodash": "^4.17.19" },  
"node": ">=0.10.0" }, "peerDependencies": { "request": "^2.34"  
"peer": true,  
"node": ">=0.12.0"  
"node": ">=0.10.0"  
"node": ">=0.10.0"  
"peer": true, "engines": { "node": ">=4"  
"peer": true,  
"iojs": ">=1.0.0", "node": ">=0.10.0"  
"glob": "^7.1.3"  
"rimraf": "bin.js"  
"dependencies": { "hash-base": "^3.0.0", "inherits": "^2.0.1"  
"bn.js": "^5.2.0"  
"bin": { "rlp": "bin/rlp"  
"dependencies": { "queue-microtask": "^1.2.2"  
"queue-microtask": "^1.2.2"  
"peer": true,  
"bin": { "istanbul": "lib/cli.js"  
"peer": true,  
"sprintf-js": "~1.0.2"  
"peer": true,  
"node": "*"  
{  
"peer": true,  
"node": ">=0.10.0"  
"peer": true, "dependencies": { "has-flag": "^1.0.0" },  
"node": ">=0.8.0"  
"node": ">=10.0.0"  
"bin": { "semver": "bin/semver.js"  
"randombytes": "^2.1.0"  
"dependencies": { "inherits": "^2.0.1", "safe-buffer": "^5.0.1"  
"bin": { "sha.js": "bin.js"  
"dependencies": { "charenc": ">= 0.0.1", "crypt": ">= 0.0.1" },  
"node": "*"  
"shjs": "bin/shjs"  
"node": ">=4"  
"node": ">=8"  
"color-convert": "^2.0.1"  
"color-name": "~1.1.4"  
"node": ">=7.0.0"  
"node": ">=8.0.0"  
{ "graceful-fs": "^4.1.6"  
"bin": { "semver": "bin/semver"  
"peerDependencies": { "hardhat": "^2.11.0"  
"antlr4ts": "^0.5.0-alpha.4"  
"peer": true,  
"node": ">=6"  
"peer": true,  
"node": ">=6"  
"peer": true,  
"sprintf-js": "~1.0.2"  
"node": ">=6"  
"node": ">= 8.10.0"  
{ "fsevents": "~2.1.1"  
"peer": true,  
"string-width": "^3.1.0", "strip-ansi": "^5.2.0", "wrap-ansi": "^5.1.0"  
"peer": true,  
"ms": "^2.1.1"  
{  
"engines": { "node": ">=0.10.0"  
"peer": true, "engines": { "node": ">=0.3.1"  
"locate-path": "^3.0.0"  
"engines": { "node": ">=6"  
"is-buffer": "~2.0.3" }, "bin": { "flat": "cli.js"  
"graceful-fs": "^4.2.0", "jsonfile": "^4.0.0", "universalify": "^0.1.0"  
"node": ">=6 <7 || >=8"  
"node": "^8.16.0 || ^10.6.0 || >=11.0.0"  
"engines": { "node": "*"  
"argparse": "^1.0.7", "esprima": "^4.0.0"  
"bin": { "js-yaml": "bin/js-yaml.js"  
"peer": true,  
"p-locate": "^3.0.0", "path-exists": "^3.0.0"  
"node": ">=6"  
{  
"peer": true,  
"yallist": "^4.0.0" }, "engines": { "node": ">=10"  
"peer": true,  
"brace-expansion": "^1.1.7"  
"engines": { "node": "*"  
"minimist": "^1.2.5"  
"bin": { "mkdirp": "bin/cmd.js"  
"_mocha": "bin/_mocha", "mocha": "bin/mocha"  
"peer": true  
"peer": true,  
"p-try": "^2.0.0"  
"node": ">=6"  
"url":  
"peer": true,  
"p-limit": "^2.0.0"  
"peer": true,  
"picomatch": "^2.0.4"  
"node": ">= 8"  
"peer": true,  
"lru-cache": "^6.0.0"  
"semver": "bin/semver.js"  
"node": ">=10"  
"peer": true,  
"ansi-regex": "^4.1.0"  
"engines": { "node": ">=6"  
"node": ">=0.10.0"  
{  
"has-flag": "^3.0.0"  
"node": ">=6"  
"node": ">=6"  
"busboy": "^1.6.0"  
"^4.9.3",  
"packageManager": "pnpm@8.15.5",  
"4.20240329.0",  
"@types/node": "20.12.2", "better-sqlite3": "9.4.3",  
"0.37.77",  
"drizzle-orm": "0.30.6",  
"hono": "4.1.7",  
"miniflare": "3.20240320.1",  
"nanoid": "5.0.6",  
"remeda": "1.57.0",  
"typescript": "5.4.3", "undici-types": "6.10.1",  
"wrangler": "3.41.0"  
version:  
specifier: 4.20240329.0 version: 4.20240329.0  
specifier: 20.12.2 version: 20.12.2  
specifier: 9.4.3 version: 9.4.3  
specifier: 0.37.77 version: 0.37.77  
specifier: 4.1.7 version: 4.1.7  
specifier: 3.20240320.1 version: 3.20240320.1  
specifier: 5.0.6 version: 5.0.6  
specifier: 1.57.0 version: 1.57.0  
version:  
specifier: 5.4.3 version: 5.4.3  
specifier: 6.10.1 version: 6.10.1  
version:  
specifier: 3.41.0 version:  
 
4.20240329.0  
'@types/node': 20.12.2  
'@types/node': 20.12.2  
 
semver: 7.5.4 ts-api-utils: typescript: 5.4.3  
 
 
typescript: 5.4.3  
 
ts-api-utils: typescript: 5.4.3  
 
ts-api-utils: typescript: 5.4.3  
 
 
semver: 7.5.4  
'@vercel/postgres': '*'  
4.20240329.0 better-sqlite3: 9.4.3  
 
semver: 7.5.4  
semver: 7.5.4  
workerd: 1.20240320.1  
 
typescript: 5.4.3  
 
typescript: 5.4.3  
 
vite:  
 
'@types/node': 20.12.2  
vitest:  
 
'@types/node': 20.12.2  
vite: vite-node:  
^4.20240320.1  
4.20240329.0  
miniflare: 3.20240320.1  
